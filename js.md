# Скрипты

Все скрипты лежат в `templates/src/js/`.

```
js/                     # Скрипты
    ├── BView/          # Backbone Views ("вьюхи" / представления страниц сайта)
        └── subView/    # Модули, которые могут использоваться в нескольких вьюхах
    ├── components/     # Базовые компоненты для работы сайта
    ├── core/           # Базовые классы, от которых расширяются вьюхи
    ├── libs/           # Сторонние библиотеки
    └── script.js       # Точка входа для скриптов (инициализация приложения)
```

Для организации кода и реализации SPA в проекте используется фреймворк Backbone. Однако совсем не обязательно знать Backbone от и до для того, чтобы начать писать свой js код.

Backbone - MVP фреймворк \([Model-View-Presenter](https://ru.wikipedia.org/wiki/Model-View-Presenter)\), но, как правило, в большинстве проектов не используется Model, а стало быть и Presenter. Работа идет только с [View](http://backbonejs.org/#View).

View используется для организации модульности кода. Отсюда можно воспринимать View просто как модуль. Во View содержится весь js, который иcпользуется на странице. Таким образом, одна страница = одна вьюха.

Вьюха привязывается к странице \(а точнее к URL\) с помощью атрибута `data-view`. Раньше мы пытались использовать [статическую таблицу роутинга](http://backbonejs.org/#Router-routes), но потом от нее отказались. Дело в том, что в большинстве проектов используется наша админка, в которой можно управлять деревом разделов \(добавлять, удалять и менять URL\). А поддерживать таблицу роутинга в актуальном состоянии после каждого изменения в админке довольно сложно. Генерировать её из админки тоже довольно сложно. Поэтому мы упростили роутинг, и на каждой странице выводим `data-view="<ИМЯ_ВЬЮХИ>"`, который определяет текущую вьюшку.

Вьюхи нужно класть в `templates/src/js/BView/`. Из коробки уже присутствуют такие вьюхи:

```
Footer.js - вьюха футера
Header.js - вьюха хедера
Index.js - вьюха главной страницы
NotFound.js - вьюха страницы 404
Page1.js - демонстрационная вьюха
```

Таким образом, если вы создали страницу `news.php`, то для нее необходимо создать вьюху `News.js`, а в `news.php` указать `data-view="News"`.

```php
<? define('PAGE_JS_VIEW','News'); ?>
<div class="news" data-view="<?=PAGE_JS_VIEW?>"> ... </div>
```

То же самое, если вы верстаете на Jade \(см. [Верстка на Jade](jade.md)\):

```jade
+module(MODULE.DEFINE_VIEW, {view: 'News'})
block content
    .news(data-view!='<?=PAGE_JS_VIEW?>')
```

## Структура View

Рассмотрим структуру View на примере `News.js`.

```js
// Вьюхи страниц нужно класть в app.views и наследовать от app.core.Page
app.ns('app.views').News = app.core.Page.extend({

  // Обработчики событий
  events: {},

  // Инициализация вьюхи (когда пришли на страницу)
  initialize () {
    app.views.News.__super__.initialize.apply(this, arguments); 
  },

  // Удаление вьюхи и обработчиков (когда ушли со страницы)
  remove () {
    app.views.News.__super__.remove.apply(this, arguments); 
  },

  // Отрисовка в DOM
  render () {
    app.views.News.__super__.render.apply(this, arguments);
    app.views.News.__super__.afterRender.apply(this, arguments);
  }
})
```

## Работа с View

Свой код нужно писать в методе `render()`. Если кода получается больше, чем на 10 строк, его следует выносить в отдельные методы.

```js
app.ns('app.views').News = app.core.Page.extend({
  render () {
    this.method1()
    this.method2()
  },
  method1 () {...},
  method2 () {...}
})

```

Обработчики событий нужно вешать декларативно в объекте `events` \(это стандартное [делегирование событий в Backbone](http://backbonejs.org/#View-delegateEvents)\). События записываются в следующем формате `{"событие селектор": "обработчик"}`. Например:

```js
events: {
  'click .js-filter-reset': 'e_resetFilters',
  'change .a-checkbox__input': 'e_toggleCheckbox',
  'keyup .js-search-input': '_e_searchInput',
  'focus .js-search-input': function () { ... },
}
```

Профит от такого подхода в том, что при уходе со страницы \(при смене вьюхи\) обработчики снимаются автоматически.

**Обратите внимание \#1!** Backbone требует, чтобы вьюхи были привязаны к конкретному DOM элементу. По умолчанию таким элементом является `<div class="grid"></div>`. Поэтому если в верстке вы, по какой-то причине, решили изменить класс корневого элемента для вьюх, не забудьте поменять его также и в `templates/src/js/components/Application.js`!

**Обратите внимание \#2!** Если, по какой-то причине, вы вешаете обработчик jQuery способом, то нужно обязательно его снять в методе `remove()`. Иначе при уходе на другую страницу обработчик так и останется висеть в памяти, что грозит ее [утечкой](http://learn.javascript.ru/memory-leaks-jquery). Чем больше неиспользуемых обработчиков в памяти, тем серьезней утечка и медленнее работает сайт. Это не касается вьюх, чей код используется на всем сайте \(`Header.js`, `Footer.js` и т.п.\).

## Работа с subView

Код, который используется на нескольких страницах, нужно класть в `templates/src/js/BView/subView` и вызывать на тех страницах \(вьюхах\), где необходимо. Это не относится к хедеру и футеру, т.к. традиционно они уже подключены и находятся в `templates/src/js/BView/`. Работа с сабвьюхами почти ничем не отличается от работы с вьюхами за исключением некоторых нюансов:

```js
// Сабвьюхи нужно класть в app.subViews и наследовать от app.core.View
app.ns('app.subViews').MarkNewsAsRead = app.core.View.extend({

  // Для сабвьюх всегда нужно указывать корневой DOM элемент в свойстве `el`
  el: '.article',

  ...

})
```

Вызвать сабвьюху можно в свойстве `subView` любой вьюхи следующим образом:

```js
app.ns('app.views').News = app.core.Page.extend({

  subView: {
    MarkNewsAsRead: 'MarkNewsAsRead'
  },

})
```

## Линтер

В качестве линтера в сборке используется инструмент [standard](https://standardjs.com/). Он диктует жесткий кодстайл, но в большой команде это единственный способ писать единообразный код (и не тратить время на холивары "табы или пробелы"). Поэтому, если ранее вы не сталкивались с этим инструментом то, перед тем, как начинать кодить, рекомендуется изучить правила, которые он предлагает. Чтобы ваш редактор автоматически форматировал код в соответствии с этими правилами, также будет не лишним установить соответствующий [плагин](https://standardjs.com/index.html#are-there-text-editor-plugins).

## Добавление библиотек и плагинов

В сборке предусмотрено 2 способа добавления либ:

1. Скачать файл либы с официального сайта или github и положить его в папку `templates/src/js/libs`. После этого перезапустить сборку.
1. Установить либу через `npm`. После этого нужно добавить ссылку на файл либы в список `config.jsLibsList` в `gulp-config.js` и перезапустить сборку.

```js
config.jsLibsList = [
  'node_modules/swiper/dist/js/swiper.js', // Либа, установленная через npm
  config.sourcePathScripts + '/libs/*.js',
  config.sourcePathScripts + '/libs/**/*.js'
]
```

Если либа использует свой глобальный объект (как, например, `$` в jQuery), его нужно добавить в список `globals` в `templates/package.json`, чтобы линтер на него не ругался.

```
"standard": {
  "globals": [
    "$",
    "_",
    "Backbone",
    "Modernizr",
    "device",
    "Swiper",
    "app"
  ]
}
```