# Frontend quick guide

В дефолтной сборке используются сборщик Gulp, препроцессор LESS. 

HTML код пишется в PHP файлах. При этом PHP знать почти не обязательно - можно писать обычный HTML, - а при некотором знании можно даже использовать PHP в качестве шаблонизатора.

## Разворачивание проекта

- Скачиваем репозиторий [libs](http://hg.turbodevelopers.com/turbo/libs)
- Переходим в крайнюю ревизию ветки `altVersion-ks`
- Создаем папку для нового проекта, копируем туда все содержимое из `libs`
- В терминале переходим в папку `имя_проекта\templates` и запускаем `npm install` для установки npm модулей

## Типовая структура проекта

Прежде, чем говорить о верстке, необходимо описать типовую струткуру проекта.

```
templates                           # Весь фронтенд проекта
    ├── build/                      # Итоговые файлы для разработки и продакшена. Здесь не нужно ничего трогать, т.к. все файлы пересобираются сборщиком автоматически.
        ├── css/                    # Итоговые css файлы (dev и min версии)
        ├── js/                     # Итоговые js файлы (dev и min версии)
        └── images/                 # Сжатые картинки и итоговые спрайты
    ├── components/                 # PHP компоненты проекта
    ├── fonts/                      # Шрифты, если шрифтов несколько, то лучше раложить их по папкам
    ├── gulp/                       # Gulp таски, сюда лезть скорее всего не придется, т.к. из коробки все что нужно уже настроено
    ├── images/                     # Картинки для проекта, лучше раскладывать их по папкам
    ├── pages/                      # PHP страницы проекта
    ├── sprites/                    # Исходники для спрайтов
        ├── png/                    # Картинки для png спрайтов
        └── svg/                    # Картинки для svg спрайтов
    ├── src/                        # Исходный код проекта
        ├── js/                     # Скрипты
            ├── BView/              # Backbone Views ("вьюхи")
                └── subView/        # "Сабвьюхи" - модули, которые могут использоваться в нескольких вьюхах
            ├── components/         # Компоненты
            ├── core/               # Базовые скрипты
            ├── libs/               # Сторонние библиотеки
            └── script.js           # Точка входа для скриптов (инициализация приложения)
        ├── less/                   # Стили
            ├── core/               # Базовые стили (normalize, шрифты, спрайты и т.п.)
            ├── common/             # Базовые модули (header, footer и т.п.)
            ├── modules/            # Все остальные модули
            ├── libs/               # Стили библиотек и плагинов
            └── styles.less         # Точка входа для стилей        
    ├── BODY.tpl.php                # Точка входа для PHP страниц
    └── gulpfile.js                 # Файл настроек gulp для сборки проекта
```

## HTML верстка

Как уже было сказано, вся верстка делается в PHP файлах, при этом PHP знать почти не обязательно - пишите обычный HTML.

Для верстки предусмотрены 2 папки: `components` и `pages`.

В `components` кладутся куски кода, которые встречаются более, чем на одной странице (хедер, футер и т.п.). Таким образом, мы пишем код всего один раз и подключаем его где хотим через директиву `include` или функцию `component()` (которая делает тот же самый `include`, но чуть удобней).

```php
<? 
// Подключение компонента
component('head'); 
?>
```

В `pages` кладутся непосредственно страницы сайта (index, news, contatcs и т.п.). Под страницей подразумевается кусок сайта между хедером и футером. Страницы могут включать в себя как компоненты, так и уникальный код.

Кроме этого, в папке templates лежит файл `BODY.tpl.php` - в нем подключаются хедер, футер и ряд других компонентов, а также находится точка входа для всех страниц сайта (переменная `<?=$CONTENT?>`). 

Таким образом, чтобы создать страницу новостей, нужно в папке `pages` создать файл `news.php`. Он автоматически подхватится точкой входа и станет доступен по адресу `имя_проекта/news`.

## Стили

Стили нужно писать модульно. Один файл должен содержать ровно ОДИН модуль (например, в `header.less` должны быть стили только для хедера). Название файла и класса по возможности должны совпадать.

Все файлы подключаются через директиву `@import` в одной точке входа - `styles.less`. Соответственно при добавлении нового файла со стилями его нужно не забыть подключить в `styles.less`.

```less
@import "modules/news";
```

В папке `core` содержаться базовые стили, которые со временем не будут меняться, либо будут меняться крайне редко. Сюда относятся: переменные, миксины, normalize/reset, подключение шрифтов, спрайтов и т.п..

В папку `libs` складываются стили библиотек и плагинов. Можно кидать сюда `css` и подключать в точке входа через `@import` с флагом `(less)`.

```less
@import (less) "libs/swiper.css";
```

В папке `common` складываются базовые стили (для тегов, врапперов, сеток и т.п.) и базовые модули проекта (header, footer).

Стили всех остальных модулей складываются в папку `modules`.

## Скрипты

Для организации кода и реализации SPA в проекте используется фреймворк Backbone. Однако совсем не обязательно знать Backbone от и до для того, чтобы начать писать свой js код. Поскольку много полезных фич, таких как, например, роутинг, уже настроены и работают из коробки.

Backbone - MVP фреймворк (Model-View-Presenter), но, как правило, в большинстве проектов не используется Model, а стало быть и Presenter. Работа идет только с View, который используется для организации модульности. Отсюда можно воспринимать View просто как модуль.
 
Во View содержится весь js, который ипользуется на странице. Таким образом, одна страница = одна вьюха. Вьюха привязывается к странице с помощью атрибута `data-view`. Например, если вы создали страницу `news.php`, то для нее необходимо создать вьюху `News.js`, а на самой странице прописать `data-view="News"`.

**HTML**
```php
<div class="news" data-view="News"> ... </div>
```

**PHP**
```
<?
define('PAGE_JS_VIEW','News');
?>
<div class="news" data-view="<?=PAGE_JS_VIEW?>"> ... </div>
```


### Структура View

```js
app.ns('app.views').News = app.core.Page.extend({

	events: {},

	initialize: function() {
		app.views.News.__super__.initialize.apply(this, arguments);
	},

	remove: function() {
		app.views.News.__super__.remove.apply(this, arguments);
	},

	render: function() {
		app.views.News.__super__.render.apply(this, arguments);
		app.views.News.__super__.afterRender.apply(this, arguments);
	}
});
```

### Работа с View

Свой код нужно писать в методе `render()`.
  
Обработчики событий нужно вешать декларативно в объекте `events`. События записываются в следующем формате `{"событие селектор": "обработчик"}`. Профит от такого подхода в том, что при уходе со страницы обработчики снимаются автоматически.

**Обратите внимание!** Backbone требует, чтобы вьюхи были привязаны к конкрерному DOM элементу. По-умолчанию таким элементом является `<div class="grid"></div>`. Поэтому если в верстке вы по какой-то причине решили изменить класс корневого элемента для вьюх, не забудьте поменять его также и в `Application.js`!

### Работа с subView

Код, который используется на нескольких страницах, нужно класть в папку `subView` и вызывать на тех страницах, где необходимо. Работа с сабвьюхами почти ничем не отличается от работы с вьюхами за исключением нескольких особенностей.

Для сабвьюх всегда нужно указывать корневой DOM элемент в свойстве `el`.

```js
app.views.MarkNewsAsRead = Backbone.View.extend({

	el: '.article',

	...
  
});
```

Вызов сабвьюхи выглядит следующим образом:

```js
this.subView['MarkNewsAsRead'] = new app.views.MarkNewsAsRead();
this.subView['MarkNewsAsRead'].render();

// или так
var MarkNewsAsRead = this.subView['MarkNewsAsRead'] = new app.views.MarkNewsAsRead();
MarkNewsAsRead.render();
```

### Быстрая настройка резины на ремах

Управление резиной осуществляется в файле `Adaptive.js`. В большинстве случаев достаточно лишь правильно указать базовые опции в объекте `cfgs`. Для определения устройства используется библиотека `Device.js`.

**Описание опций**

```
<class> : {                                                    // Условия выставления класса <class>
    if: <if>                                                   // условие (функция(<data>,<cfg>)) <data> содержит $el, elWidth, elHeight
    element: < selector || element || $element || domKey >,    // элемент по которому происходят рассчеты размеров
    rem: <px>                                                  // коэфициент перевода rem => px (отменяет зависимость по base)
    from: {                                                    //
        width: <fromWidth> ,                                   // Минимальная ширина элемента
        height: <fromHeight>                                   // Минимальная высота элемента
    },
    to: {
        width: <toWidth> ,                                     // Максимальная ширина элемента
        height: <toHeight>                                     // Максимальная высота элемента
    },
    base: {
        width: <toWidth> ,                                     // Базовая ширина элемента для рассчета коэфициента
        height: <toHeight>                                     // Базовая высота элемента для рассчета коэфициента
    },
    k: <k>,                                                    // Дополнительный коэффициент
    setClass: false || true || <class>,                        // выставлять класс при выполнении условий
    setNoClass: false || true || <class>,                      // выставлять класс при невыполнении условий
    setDeviceType: true || false || <type>,                    // устанавливать новый deviceType при соответствии условиям (key <class> из конфигурации или конкретный <type>)
}
```

Простейшая настройка выглядит следующим образом:

```js
this.cfgs = {
    'desktop': {
        if: device.desktop, // Если устройство определено как desktop
        setClass: true,     // Выставить класс 'desktop'
        setNoClass: true,   // Выставить класс 'no-desktop'
        setDeviceType: true // Принудительно установить тип устройства как desktop
    },
    'tablet': {
        if: device.tablet,
        setClass: true,
        setNoClass: true,
        setDeviceType: true
    },
    'mobile': {
        if: device.mobile,
        setClass: true,
        setNoClass: true,
        setDeviceType: true
    },
};
```

В примере выше мы настроили добавление классов на страницу в зависимости от устройства. Однако там еще не подключена резина. Рассмотрим более сложный кейс. Предположим, ширина контентной части в макете = 1200px. Соответственно на разрешениях < 1200px лэйаут начнет ломаться. Чтобы этого не происходило, нужно включать резину на этих разрешениях.

```js
this.cfgs = {
    'desktop': {
        if: device.desktop,
        setClass: true,
        setNoClass: true,
        setDeviceType: true
    },
    'desktop:wide': {
        if: device.desktop,    // Если устройство определено как desktop
        rem: 10,               // Использовать для расчета базовый коэффициент (отключает скейл)
        from: {
            width: 1200        // Применить от 1200px по ширине
        }
    },
    'desktop:thin': {
        if: device.desktop,    // Если устройство определено как desktop
        base: {
            width: 1200        // Использовать для расчета базовую ширину (включает скейл)
        },
        to: {
            width: 1200        // Применить до 1200px по ширине
        }
    },
    'tablet': {...},
    'mobile': {...},
};
```

Обратите внимание: опция `rem` отключает скейл страницы, в то время как `base`, наоборот, включает. Приоритет у `rem` выше, чем у `base`, поэтому писать их вместе бессмысленно.

## Сборка проекта

Задачи из `gulpfile.js` запускаются в терминале в папке `templates` по команде `gulp <имя задачи>`.

### `gulp default` или просто `gulp`

Основная задача сборки на стадии разработки проекта.
- содержит задачи упрощающие процесс разработки
- следит за изменениями в исходных файлах, при необходимости пересобирает проект
- старается не помешать дебагу
- Запускается 1 раз перед началом сессии разработки

### `gulp release`

Основная задача сборки на стадии релиза.
- Максимально сжимает все, что можно
- Старается выпилить все лишнее

Остальные задачи так же могут запускаться вручную, но обычно в этом нет смысла.

При добавлении новых скриптов в проект (в основном это касается библиотек) возможно потребуется добавить их в списки `options.jsInitList / options.jsMainList / options.jsLibsList` в `gulpfile.js` и заново запустить задачу сборки.	

Результат сборки (в основном) складывается в папке `templates/build`.

```
templates                           
    ├── build/                      
        ├── css/
	    ├── styles.css          # во время разработки
	    └── styles.min.css      # в релизной версии подключается в <head>, содержат все стили проекта
        ├── js/
	    ├── init.js             # во время разработки
	    ├── init.min.js         # в релизной версии подключается сразу после <body>  - содержит инициализирующие скрипты, но иногда требует наличия <body> для манипуляции
	    ├── libs.js             # во время разработки
	    ├── libs.min.js         # в релизной версии подключаются перез закрытием <body> - содержат js библиотеки
	    ├── scripts.js          # во время разработки
	    └── scripts.min.js      # в релизной версии подключаются перез закрытием <body> - содержат основные скрипты
```

## Итого

- Чтобы создать страницу новостей, нужно в `templates\pages` создать файл `news.php`. Страница станет доступна по адресу `имя_проекта/news`.
- Чтобы подключить стили к странице новостей, нужно в `templates\src\less\modules` создать файл `news.less`. Затем подключить этот файл в точке входа `templates\src\less\styles.less`.
- Чтобы подключить скрипты к странице новостей, нужно в `templates\src\js\BView` создать вьюху `News.js`. Затем на странице `news.php` добавить в корневой элемент `data-view="News"`.
- Чтобы подключить резину на ремах, нужно настроить объект `cfgs` в `templates\src\js\components\Adaptive.js`.
- Перед началом разработки нужно запустить команду `gulp`, а перед релизом `gulp release`.
